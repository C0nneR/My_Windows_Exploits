// Credit for this script: DemonGan

#include <stdio.h>
#include <tchar.h>
#include <Windows.h>

void ShowError(const TCHAR* lpszText);
BOOL ExistenceOfRelocationTable(LPVOID lpBaseAddress);
LPVOID MmRunExe(LPVOID lpData, DWORD dwSize);
DWORD GetSizeOfImage(LPVOID lpData);
BOOL MmMapFile(LPVOID lpData, LPVOID lpBaseAddress);
BOOL ParseRelocationTable(LPVOID lpBaseAddress);
BOOL ParseImportTable(LPVOID lpBaseAddress);
BOOL SetImageBase(LPVOID lpBaseAddress);
BOOL CallExeEntry(LPVOID lpBaseAddress);

void ShowError(const TCHAR* lpszText)
{
	wprintf(_T("%s failed.\tGetLastError: %d.\n"), lpszText, GetLastError());
}

BOOL ExistenceOfRelocationTable(LPVOID lpBaseAddress)
{
	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddress;
	PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader->e_lfanew);
	PIMAGE_DATA_DIRECTORY pDir = (PIMAGE_DATA_DIRECTORY)&(pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC]);

	if (pDir->VirtualAddress == 0 && pDir->Size == 0) {
		return FALSE;
	}
	else {
		return TRUE;
	}
}

// lpData: pointer to file content read before
// dwSize: file size on disk
// return: pointer to file base address in memory
LPVOID MmRunExe(LPVOID lpData, DWORD dwSize)
{
	LPVOID lpBaseAddress = NULL;

	DWORD dwSizeOfImage = GetSizeOfImage(lpData);

	lpBaseAddress = VirtualAlloc(NULL, dwSizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (NULL == lpBaseAddress) {
		ShowError(_T("VirtualAlloc"));
		return NULL;
	}
	RtlZeroMemory(lpBaseAddress, dwSizeOfImage);

	if (FALSE == MmMapFile(lpData, lpBaseAddress)) {
		ShowError(_T("MmMapFile"));
		VirtualFree(lpBaseAddress, 0, MEM_RELEASE);
		return NULL;
	}

	if (FALSE == ParseRelocationTable(lpBaseAddress)) {
		ShowError(_T("ParseRelocationTable"));
		VirtualFree(lpBaseAddress, 0, MEM_RELEASE);
		return NULL;
	}

	if (FALSE == ParseImportTable(lpBaseAddress)) {
		ShowError(_T("ParseImportTable"));
		VirtualFree(lpBaseAddress, 0, MEM_RELEASE);
		return NULL;
	}

	if (FALSE == SetImageBase(lpBaseAddress)) {
		ShowError(_T("SetImageBase"));
		VirtualFree(lpBaseAddress, 0, MEM_RELEASE);
		return NULL;
	}

	if (FALSE == CallExeEntry(lpBaseAddress)) {
		ShowError(_T("CallExeEntry"));
		VirtualFree(lpBaseAddress, 0, MEM_RELEASE);
		return NULL;
	}

	return lpBaseAddress;
}

DWORD GetSizeOfImage(LPVOID lpData)
{
	DWORD dwSizeOfImage = 0;
	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpData;
	PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader->e_lfanew);
	dwSizeOfImage = pNtHeaders->OptionalHeader.SizeOfImage;

	return dwSizeOfImage;
}

BOOL MmMapFile(LPVOID lpData, LPVOID lpBaseAddress)
{
	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpData;
	PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader->e_lfanew);
	DWORD dwSizeOfHeaders = pNtHeaders->OptionalHeader.SizeOfHeaders;
	WORD wNumberOfSections = pNtHeaders->FileHeader.NumberOfSections;
	PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pNtHeaders + sizeof(IMAGE_NT_HEADERS));

	RtlCopyMemory(lpBaseAddress, lpData, dwSizeOfHeaders);

	WORD i = 0;
	LPVOID lpSrcMem = NULL;
	LPVOID lpDestMem = NULL;
	DWORD dwSizeOfRawData = 0;

	for (i = 0; i < wNumberOfSections; i++) {
		if ((0 == pSectionHeader->VirtualAddress) || (0 == pSectionHeader->SizeOfRawData)) {
			pSectionHeader++;
			continue;
		}

		lpSrcMem = (LPVOID)((DWORD)lpData + pSectionHeader->PointerToRawData);
		lpDestMem = (LPVOID)((DWORD)lpBaseAddress + pSectionHeader->VirtualAddress);
		dwSizeOfRawData = pSectionHeader->SizeOfRawData;
		RtlCopyMemory(lpDestMem, lpSrcMem, dwSizeOfRawData);

		pSectionHeader++;
	}

	return TRUE;
}

BOOL ParseRelocationTable(LPVOID lpBaseAddress)
{
	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddress;
	PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader->e_lfanew);
	PIMAGE_BASE_RELOCATION pLoc = (PIMAGE_BASE_RELOCATION)((ULONG32)pDosHeader + pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
	DWORD dwDelta = (DWORD)pDosHeader - pNtHeaders->OptionalHeader.ImageBase;

	while ((pLoc->VirtualAddress + pLoc->SizeOfBlock) != 0) {
		WORD* pLocData = (WORD*)((PBYTE)pLoc + sizeof(IMAGE_BASE_RELOCATION));
		int nNumberOfReloc = (pLoc->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);

		for (int i = 0; i < nNumberOfReloc; i++) {
			if ((pLocData[i] & 0xF000) == 0x3000) {
				DWORD* pAddress = (DWORD*)((PBYTE)pDosHeader + pLoc->VirtualAddress + (pLocData[i] & 0x0FFF));
				*pAddress += dwDelta;
			}
		}

		pLoc = (PIMAGE_BASE_RELOCATION)((PBYTE)pLoc + pLoc->SizeOfBlock);
	}

	return TRUE;
}

BOOL ParseImportTable(LPVOID lpBaseAddress)
{
	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddress;
	PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader->e_lfanew);
	PIMAGE_IMPORT_DESCRIPTOR pImportTable = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)pDosHeader + pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);

	CHAR* lpDllName = NULL;
	HMODULE hDll = NULL;
	PIMAGE_THUNK_DATA lpImportNameArray = NULL;
	PIMAGE_IMPORT_BY_NAME lpImportByName = NULL;
	PIMAGE_THUNK_DATA lpImportFuncAddrArray = NULL;
	FARPROC lpFuncAddress = NULL;
	DWORD i = 0;

	while (TRUE) {
		if (0 == pImportTable->OriginalFirstThunk) {
			break;
		}

		lpDllName = (CHAR*)((DWORD)pDosHeader + pImportTable->Name);
		hDll = GetModuleHandleA(lpDllName);
		if (NULL == hDll) {
			hDll = LoadLibraryA(lpDllName);
			if (NULL == hDll) {
				pImportTable++;
				continue;
			}
		}

		i = 0;
		lpImportNameArray = (PIMAGE_THUNK_DATA)((DWORD)pDosHeader + pImportTable->OriginalFirstThunk);
		lpImportFuncAddrArray = (PIMAGE_THUNK_DATA)((DWORD)pDosHeader + pImportTable->FirstThunk);

		while (TRUE) {
			if (0 == lpImportNameArray[i].u1.AddressOfData) {
				break;
			}

			lpImportByName = (PIMAGE_IMPORT_BY_NAME)((DWORD)pDosHeader + lpImportNameArray[i].u1.AddressOfData);
			if (0x80000000 & lpImportNameArray[i].u1.Ordinal) {
				lpFuncAddress = GetProcAddress(hDll, (LPCSTR)(lpImportNameArray[i].u1.Ordinal & 0x0000FFFF));
			}
			else {
				lpFuncAddress = GetProcAddress(hDll, (LPCSTR)lpImportByName->Name);
			}

			lpImportFuncAddrArray[i].u1.Function = (DWORD)lpFuncAddress;
			i++;
		}

		pImportTable++;
	}

	return TRUE;
}

BOOL SetImageBase(LPVOID lpBaseAddress)
{
	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddress;
	PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader->e_lfanew);
	pNtHeaders->OptionalHeader.ImageBase = (ULONG32)lpBaseAddress;

	return TRUE;
}

BOOL CallExeEntry(LPVOID lpBaseAddress)
{
	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddress;
	PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader->e_lfanew);
	LPVOID lpExeEntry = (LPVOID)((ULONG32)pDosHeader + pNtHeaders->OptionalHeader.AddressOfEntryPoint);

	__asm {
		mov eax, lpExeEntry
		jmp eax
	}

	return TRUE;
}

int main()
{
	TCHAR szFilename[] = _T("calc.exe");

	HANDLE hFile = CreateFile(szFilename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (INVALID_HANDLE_VALUE == hFile) {
		ShowError(_T("CreateFile"));
		return 1;
	}

	DWORD dwFileSize = GetFileSize(hFile, NULL);
	if (INVALID_FILE_SIZE == dwFileSize) {
		ShowError(_T("GetFileSize"));
		CloseHandle(hFile);
		return 2;
	}

	BYTE* pData = new BYTE[dwFileSize];
	if (NULL == pData) {
		ShowError(_T("new"));
		CloseHandle(hFile);
		return 3;
	}

	BOOL bRet = FALSE;
	DWORD dwRet = 0;
	bRet = ReadFile(hFile, pData, dwFileSize, &dwRet, NULL);
	if (FALSE == bRet || dwRet != dwFileSize) {
		ShowError(_T("ReadFile"));
		CloseHandle(hFile);
		delete[] pData;
		return 4;
	}
	CloseHandle(hFile);

	if (FALSE == ExistenceOfRelocationTable(pData)) {
		printf("Relocation table does not exist.\n");
		delete[] pData;
		return 5;
	}

	LPVOID lpBaseAddress = MmRunExe(pData, dwFileSize);
	if (NULL == lpBaseAddress) {
		ShowError(_T("MmRunExe"));
		delete[] pData;
		return 6;
	}

	delete[] pData;
	system("pause");
	return 0;
}