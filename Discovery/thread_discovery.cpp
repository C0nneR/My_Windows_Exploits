#include <stdio.h>
#include <tchar.h>
#include <Windows.h>
#include <TlHelp32.h>

DWORD GetProcessPID(const _TCHAR* pszProcessName) {
	DWORD dwPid = 0;
	PROCESSENTRY32 pe32 = { 0 };
	pe32.dwSize = sizeof(PROCESSENTRY32);

	HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (INVALID_HANDLE_VALUE == hProcessSnap) {
		printf("CreateToolhelp32Snapshot failed.\n");
		return FALSE;
	}

	BOOL bRet = Process32First(hProcessSnap, &pe32);
	while (bRet) {
		if (!lstrcmpiW(pszProcessName, pe32.szExeFile))
		{
			dwPid = pe32.th32ProcessID;
			break;
		}
		bRet = Process32Next(hProcessSnap, &pe32);
	}

	CloseHandle(hProcessSnap);
	return dwPid;
}

//BOOL EnumerateThread(DWORD dwPid) {
//	THREADENTRY32 te32 = { 0 };
//	te32.dwSize = sizeof(THREADENTRY32);
//
//	HANDLE hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
//	if (INVALID_HANDLE_VALUE == hThreadSnap) {
//		printf("CreateToolhelp32Snapshot failed with error code %d.\n", GetLastError());
//		return FALSE;
//	}
//
//	BOOL bRet = Thread32First(hThreadSnap, &te32);
//	if (bRet) {
//		printf("TheardID\n");
//	}
//	while (bRet) {
//		if (dwPid == te32.th32OwnerProcessID) {
//			printf("%d\n", te32.th32ThreadID);
//		}
//		bRet = Thread32Next(hThreadSnap, &te32);
//	}
//
//	CloseHandle(hThreadSnap);
//	return TRUE;
//}

BOOL GetThreadID(DWORD dwPid, DWORD** ppThreadId, DWORD* pdwThreadIdLength) {
	DWORD* pThreadId = NULL;
	DWORD dwThreadIdLength = 0;
	DWORD dwBufferLength = 1000;
	THREADENTRY32 te32 = { 0 };
	te32.dwSize = sizeof(te32);
	HANDLE hSnapshot = NULL;
	BOOL bRet = FALSE;

	do {
		pThreadId = new DWORD[dwBufferLength];
		if (NULL == pThreadId) {
			printf("new failed with error code %d.\n", GetLastError());
			break;
		}
		RtlZeroMemory(pThreadId, (dwBufferLength * sizeof(DWORD)));

		hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
		if (NULL == hSnapshot) {
			printf("CreateToolhelp32Snapshot failed with error code %d.\n", GetLastError());
			break;
		}

		bRet = Thread32First(hSnapshot, &te32);
		while (bRet) {
			if (dwPid == te32.th32OwnerProcessID) {
				pThreadId[dwThreadIdLength] = te32.th32ThreadID;
				dwThreadIdLength++;
			}
			bRet = Thread32Next(hSnapshot, &te32);
		}

		*ppThreadId = pThreadId;
		*pdwThreadIdLength = dwThreadIdLength;
		bRet = TRUE;
	} while (FALSE);

	return bRet;
}

int main() {
	DWORD dwRet = GetProcessPID(_T("explorer.exe"));
	if (dwRet) {
		printf("PID: %d.\n", dwRet);
	}
	else {
		printf("GetProcessPID failed.\n");
		return 1;
	}

	//if (FALSE == EnumerateThread(dwRet)) {
	//	printf("EnumerateThread failed.\n");
	//}
	//else {
	//	printf("EnumerateThread succeeded.\n");
	//}

	DWORD* pThreadId = NULL;
	DWORD dwThreadIdLength = 0;
	if (FALSE == GetThreadID(dwRet, &pThreadId, &dwThreadIdLength)) {
		printf("GetThreadID failed.\n");
	}
	else {
		printf("GetThreadID succeeded.\n");
		printf("ThreadID\n");
		for (DWORD i = 0; i < dwThreadIdLength; i++) {
			printf("%d\n", pThreadId[i]);
		}
	}

	if (NULL != pThreadId) {
		delete[] pThreadId;
		pThreadId = NULL;
	}

	system("pause");
	return 0;
}