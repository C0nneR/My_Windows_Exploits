#include <stdio.h>
#include <tchar.h>
#include <Windows.h>
#include <TlHelp32.h>

DWORD GetProcessPID(const _TCHAR* pszProcessName) {
	DWORD dwPid = 0;
	PROCESSENTRY32 pe32 = { 0 };
	pe32.dwSize = sizeof(PROCESSENTRY32);

	HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (INVALID_HANDLE_VALUE == hProcessSnap) {
		printf("CreateToolhelp32Snapshot failed.\n");
		return FALSE;
	}

	BOOL bRet = Process32First(hProcessSnap, &pe32);
	while (bRet) {
		if (!lstrcmpiW(pszProcessName, pe32.szExeFile))
		{
			dwPid = pe32.th32ProcessID;
			break;
		}
		bRet = Process32Next(hProcessSnap, &pe32);
	}

	CloseHandle(hProcessSnap);
	return dwPid;
}

BOOL GetThreadID(DWORD dwPid, DWORD** ppThreadId, DWORD* pdwThreadIdLength) {
	DWORD* pThreadId = NULL;
	DWORD dwThreadIdLength = 0;
	DWORD dwBufferLength = 1000;
	THREADENTRY32 te32 = { 0 };
	te32.dwSize = sizeof(te32);
	HANDLE hSnapshot = NULL;
	BOOL bRet = FALSE;

	do {
		pThreadId = new DWORD[dwBufferLength];
		if (NULL == pThreadId) {
			printf("new failed with error code %d.\n", GetLastError());
			break;
		}
		RtlZeroMemory(pThreadId, (dwBufferLength * sizeof(DWORD)));

		hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
		if (NULL == hSnapshot) {
			printf("CreateToolhelp32Snapshot failed with error code %d.\n", GetLastError());
			break;
		}

		bRet = Thread32First(hSnapshot, &te32);
		while (bRet) {
			if (dwPid == te32.th32OwnerProcessID) {
				pThreadId[dwThreadIdLength] = te32.th32ThreadID;
				dwThreadIdLength++;
			}
			bRet = Thread32Next(hSnapshot, &te32);
		}

		*ppThreadId = pThreadId;
		*pdwThreadIdLength = dwThreadIdLength;
		bRet = TRUE;
	} while (FALSE);

	return bRet;
}

BOOL APCInject(const TCHAR* pszProcessName, const TCHAR* pszDllName) {
	BOOL bRet = FALSE;
	DWORD dwPid = 0;
	DWORD* pThreadId = NULL;
	DWORD dwThreadIdLength = 0;
	HANDLE hProcess = NULL, hThread = NULL;
	PVOID pBaseAddress = NULL;
	HMODULE hModule = NULL;
	PVOID pLoadLibraryWFunc = NULL;
	SIZE_T dwRet = 0;
	SIZE_T dwDllPathLen = (1 + _tcslen(pszDllName)) * sizeof(TCHAR);

	do {
		dwPid = GetProcessPID(pszProcessName);
		if (dwPid <= 0) {
			printf("GetProcessPID failed.\n");
			bRet = FALSE;
			break;
		}

		bRet = GetThreadID(dwPid, &pThreadId, &dwThreadIdLength);
		if (FALSE == bRet) {
			printf("GetThreadID failed.\n");
			bRet = FALSE;
			break;
		}

		hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);
		if (NULL == hProcess) {
			printf("OpenProcess failed with error code %d.\n", GetLastError());
			bRet = FALSE;
			break;
		}

		pBaseAddress = VirtualAllocEx(hProcess, NULL, dwDllPathLen, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
		if (NULL == pBaseAddress) {
			printf("VirtualAllocEx failed with error code %d.\n", GetLastError());
			bRet = FALSE;
			break;
		}

		if (FALSE == WriteProcessMemory(hProcess, pBaseAddress, pszDllName, dwDllPathLen, &dwRet)) {
			printf("WriteProcessMemory failed with error code %d.\n", GetLastError());
			bRet = FALSE;
			break;
		}

		hModule = GetModuleHandle(_T("kernel32.dll"));
		if (hModule == NULL) {
			printf("GetModuleHandle failed with error code %d.\n", GetLastError());
			bRet = FALSE;
			break;
		}

		pLoadLibraryWFunc = GetProcAddress(hModule, "LoadLibraryW");
		if (NULL == pLoadLibraryWFunc) {
			printf("GetProcAddress failed with error code %d.\n", GetLastError());
			bRet = FALSE;
			break;
		}

		for (DWORD i = 0; i < dwThreadIdLength; i++) {
			hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, pThreadId[i]);
			if (hThread) {
				QueueUserAPC((PAPCFUNC)pLoadLibraryWFunc, hThread, (ULONG_PTR)pBaseAddress);
				CloseHandle(hThread);
				hThread = NULL;
			}
		}

		bRet = TRUE;
	} while (FALSE);

	if (hProcess) {
		CloseHandle(hProcess);
		hProcess = NULL;
	}
	if (pThreadId) {
		delete[] pThreadId;
		pThreadId = NULL;
	}
	return bRet;
}

int main() {
	BOOL bRet = FALSE;
	bRet = APCInject(_T("explorer.exe"), _T("C:\\Test\\test.dll"));
	if (bRet) {
		printf("APCInject succeeded.\n");
	}
	else {
		printf("APCInject failed.\n");
	}

	system("pause");
	return 0;
}