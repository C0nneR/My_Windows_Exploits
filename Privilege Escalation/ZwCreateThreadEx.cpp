#include <stdio.h>
#include <tchar.h>
#include <Windows.h>
#include <TlHelp32.h>

DWORD GetProcessPID(const _TCHAR* pszProcessName) {
	DWORD dwPid = 0;
	PROCESSENTRY32 pe32 = { 0 };
	pe32.dwSize = sizeof(PROCESSENTRY32);

	HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (INVALID_HANDLE_VALUE == hProcessSnap) {
		printf("CreateToolhelp32Snapshot failed.\n");
		return FALSE;
	}

	BOOL bRet = Process32First(hProcessSnap, &pe32);
	while (bRet) {
		if (!lstrcmpiW(pszProcessName, pe32.szExeFile))
		{
			dwPid = pe32.th32ProcessID;
			break;
		}
		bRet = Process32Next(hProcessSnap, &pe32);
	}

	CloseHandle(hProcessSnap);
	return dwPid;
}

BOOL ZwCreateThreadExInjectDll(DWORD dwPid, const TCHAR* pszDllFilename) {
	BOOL bRet = FALSE;
	HANDLE hProcess = NULL;
	SIZE_T dwSize = 0;
	LPVOID pDllNameAddr = NULL;
	HMODULE hModule = NULL;
	FARPROC pFuncProcAddr = NULL;
	HANDLE hRemoteThread = NULL;

	hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);
	if (NULL == hProcess) {
		printf("OpenProcess failed with error code %d.\n", GetLastError());
		return bRet;
	}

	do {
		dwSize = (1 + _tcslen(pszDllFilename)) * sizeof(TCHAR);
		pDllNameAddr = VirtualAllocEx(hProcess, NULL, dwSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
		if (NULL == pDllNameAddr) {
			printf("VirtualAllocEx failed with error code %d.\n", GetLastError());
			break;
		}

		if (FALSE == WriteProcessMemory(hProcess, pDllNameAddr, pszDllFilename, dwSize, NULL)) {
			printf("WriteProcessMemory failed with error code %d.\n", GetLastError());
			break;
		}

		hModule = GetModuleHandle(_T("kernel32.dll"));
		if (hModule == NULL) {
			printf("GetModuleHandle failed with error code %d.\n", GetLastError());
			break;
		}

		pFuncProcAddr = GetProcAddress(hModule, "LoadLibraryW");
		if (NULL == pFuncProcAddr) {
			printf("GetProcAddress failed with error code %d.\n", GetLastError());
			break;
		}

		hModule = GetModuleHandle(_T("ntdll.dll"));
		if (NULL == hModule) {
			printf("GetModuleHandle failed with error code %d.\n", GetLastError());
			break;
		}

		typedef DWORD(WINAPI* typedef_ZwCreateThreadEx)(
			PHANDLE ThreadHandle,
			ACCESS_MASK DesiredAccess,
			LPVOID ObjectAttributes,
			HANDLE ProcessHandle,
			LPTHREAD_START_ROUTINE lpStartAddress,
			LPVOID lpParameter,
			ULONG CreateThreadFlags,
			SIZE_T ZeroBits,
			SIZE_T StackSize,
			SIZE_T MaximumStackSize,
			LPVOID pUnkown);

		typedef_ZwCreateThreadEx ZwCreateThreadEx = (typedef_ZwCreateThreadEx)GetProcAddress(hModule, "ZwCreateThreadEx");
		if (NULL == ZwCreateThreadEx) {
			printf("GetProcAddress failed with error code %d.\n", GetLastError());
			break;
		}

		DWORD dwStatus = ZwCreateThreadEx(&hRemoteThread, PROCESS_ALL_ACCESS, NULL, hProcess, (LPTHREAD_START_ROUTINE)pFuncProcAddr, pDllNameAddr, 0, 0, 0, 0, NULL);
		if (NULL == hRemoteThread) {
			printf("ZwCreateThreadEx failed with error code %d.\n", GetLastError());
			break;
		}

		bRet = TRUE;
	} while (FALSE);

	CloseHandle(hProcess);
	return bRet;
}

int main() {
	DWORD dwRet = GetProcessPID(_T("explorer.exe"));
	if (dwRet) {
		printf("PID: %d.\n", dwRet);
	}
	else {
		printf("GetProcessPID failed.\n");
		return 1;
	}

	BOOL bRet = ZwCreateThreadExInjectDll(dwRet, _T("C:\\Test\\test.dll"));
	if (FALSE == bRet) {
		printf("Inject DLL failed.\n");
	}
	else {
		printf("Inject DLL succeeded.\n");
	}

	system("pause");
	return 0;
}